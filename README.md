# Marcos Proyecto(Carrera)
# Proyecto 2023
# 1.ONBOARDING BECAS OPENWEBINARS
## 1.1 Perfiles It más demandados:
-Ciberseguridad.<br>
-Big Data.<br>
-Desarrollador full stack (Mas completos que hay, combina back end y front end).<br>
## 1.2 Tecnologías mas demandadas:
-Frameworks:<br>
-Spring y Angular.
## 1.3 Mercado Global:
### 1.3.1 Principales potencias tecnológicas:
1.Reino Unido <br> 2.Alemania <br> 3.Francia <br> 4.Suecia <br> 5.España
### 1.3.2 Teletrabajo
Mucho valor de cara a trabajar para el extranjero y ponerse de manera fácil en contacto con los compañeros.
## 1.4 Talento:
Como saber que es lo que te motiva?<br>
Planificación y Prueba.<br>
Probar el máximo número posible de tecnologías distintas.<br>
Proyectos personales sencillos y aprender base de las tecnologías.<br>
## 1.5 Kaizen:
Crear hábitos diarios.<br>
Mejorar todos los dias un poco centrandose en metas pequeñas.<br>
Cultivar la mente.<br>
## 1.6 Tecnologías consolidadas o disruptivas
### 1.6.1 Tecnología disruptiva
Es la que se salta las normas y rompe los moldes, suele cambiar la forma de hacer las cosas y inventa nuevas formas, pero tambien puede fracasar (actualización constante).
### 1.6.2 Tecnología consolidadas
Tecnología que sin cambiar las reglas establecidas hace cambios importantes en la empresa de forma gradual y suave, es más segura y no tiende a fracasar (actualización constante pero no tan frenética).
## 1.7 Metodologías de estudio
Objetivos realistas y bien estructurados.<br>
Nombre y Fecha a cada tarea.<br>
Establecer un plan que puedas seguir.<br>
Éxito en ser constante.<br>
Organización y programación.<br>
Valorar tu tiempo.<br>
Establecer objetivos.<br>
Establecer un horario de estudio.<br>
## 1.8 Una buena entrevista de trabajo
Buscar información de la empresa y interesarse por ella.<br>
Ajustar tu currículum a la empresa.
Mostrar interés y preocupación por el puesto.
## 1.9 Trabajar en equipo
Compartir tu opinión y escuchar las de los demás.<br>
Ser alguien confiable.<br>
Ser flexible.<br>
## 1.10 Perfil atractivo
Cuidar las redes sociales para que reflejen lo que te representa.
# 2.Construct 2
## 2.1 Introducción a construct
Construct es un motor de juegos en 2 dimensiónes que esta pensando principalmente para relizar diseños de juegos web, aunque permite exportar los mismos a otras plataformas diferentes.<br>
Se utiliza para programar de forma visual y es muy fácil hacer prototipos en el.<br>
## 2.1.1 Utilizar construct
Para programar juegos como hobby.<br>
En caso de querer entrar en la industria del videojuego es muy fácil usar Construct para diseñar juegos y utilizarlos en el portfolio.<br>
Hacer prototipos de proyectos más grandes y testearlos.<br>
## 2.1.2 Ventajas de construct
Da muchas facilidades a la hora de diseñar un juego, y es mas fácil alcanzar metas.<br>
Ideal para equipos pequeños.<br>
Acostumbrarse a programación visual que se usa en motores mas potentes como Unreal Engine o Unity.<br>
Tiene pocas limitaciones.<br>
## 2.1.3 Desventajas de construct
Exportar a algo que no sea web es posible pero más dificil que con otros motores.<br>
Se pueden usar modelos 3D pero no muy bien.<br>
Versión gratuita limitada.<br>
## 2.2 Interfaz de Construct 08/04/2023
## 2.2.1 Vistazo general
Se trabaja sobre layouts (como se trabajaría en photoshop, Gimp...) lo que esta mas adelante es lo que tiene mas prioridad y es lo que se va a ver(sistema de capas).<br>
Coordenada 0.0 esquina superior izquierda.<br>
## 2.2.2 Properties
Son las propiedades del objeto, y muestra toda la informacion de la misma, se le puede añadir lógica a los objetos desde aqui.<br>
## 2.2.3 Layout
Donde se colocaran todos los objetos/fondos de pantalla etc.<br>
## 2.2.4 Editor
Se utiliza para hacer animaciónes y dibujar.<br>
## 2.2.5 Event sheet
Explica a Construct como manejar los objetos del layout.<br>
## 2.2.6 Play
Permite probar el juego al momento o hacer una preview(se puede compartir de forma remota al móvil).<br>
## 2.2.7 Debug layout
Permite inspeccionar los objetos del juego mientras el propio juego esta funcionando.<br>
## 2.3 Lógica de Construct 
## 2.3.1 Funcionamiento
El funcionamiento de construct es simple, los eventos vienen dados por lo siguiente.<br>
Cada evento tiene dos partes, una condición y una acción, cuando se activa la norma y que hago cuando la norma se activa.<br>
Interfaz bastante simple con menú de ayuda.<br>
## 2.3.2 Objetos
Se crean desde el menú de proyectos, se pueden añadir objetos teclado/raton que son básicamente on key downs etc. <br>
Aunque no se sepa programar, saber imaginariamente lo que puede hacer la accion.<br>
Las acciones se pueden invertir directamente.
## 2.3.2 Comportamientos
Lógicas que construct le da a los objetos.<br>
Las lógicas tienen menús editables muy fáciles de usar en los que se puede cambiar la funcionalidad de la misma casi por completo.
## 3 Prototipo
MUY RECOMENDABLE TRABAJAR CON CUADRICULAS SIEMPRE (multiplos de 32 en este caso)<br>

## 3.1 Preparar el proyecto
Empezar a preparar un proyecto de juego tipo sidescroller como el mario por ejemplo con enemigos que le atacaran.<br>
Es como hacer un "esqueleto" de lo que va a ser el juego y/o los o el niveles y lo que se pretende que hagan los enemigos respecto al jugador teniendo en cuenta las iteraciones y que no sea muy complejo.<br>
Tener una idea básica aunque no este muy definida pero si saber lo que se pretende.<br>
Partiendo de esta idea básica estructurar el juego como por ejemplo : el Jugador, que va a hacer el jugador, disparar una bala, que va a hacer la bala..etc.<br>
Estructurar las capas: Escenario con las plataformas, Escenario de fondo, Escenario con el personaje y los enemigos y un Escenario como capa por si en un futuro se quieren añadir monedas o algun tipo de puntuación.<br>
## 3.2 Planificación
### 3.2.1 Preparar el proyecto
Hacer que sea menos precario y añadir a los enemigos poco a poco cambiar controles del personaje mediante las properties( construct por default se maneja con las flechas del teclado, cambiarlo a WASD).<br>
Añadirle "IA" al enemigo( el enemigo sigue al jugador).<br>
![Construct events](https://user-images.githubusercontent.com/55932083/232007843-a9165b4e-00e4-45b0-8b22-d36067ef1e73.png)<br>
https://user-images.githubusercontent.com/55932083/232009146-bce1d8c1-95bb-4c8c-aed0-bf94b67ce60f.mp4<br>
## 3.3 Crear un personaje
### 3.3.1 Adición de variables.
En este caso queremos que el enemigo no comience a perseguir al jugador nada mas empiece el juego, si no cuadno esté a una distancia prudencial.<br>
![image](https://user-images.githubusercontent.com/55932083/232135361-4d82c30e-bf94-4317-9efd-cc227bc0408c.png)<br>
Añadiremos una nueva variable booleana.<br>
![image](https://user-images.githubusercontent.com/55932083/232135622-b1c70d16-2a9e-40a3-b28e-b8031da6fc1f.png)<br>
La variable booleana se guarda y seleccionando el enemigo podremos ir a las instance variables y ver como nuestra variable esta en "false", desactivada<br>
![image](https://user-images.githubusercontent.com/55932083/232136001-366086c5-6d7c-46da-b1c0-c85f029c6353.png)<br>
Ahora iremos a nuestros eventos y añadiremos nuevas condiciones para que el enemigo se desplace hacia el jugador<br>
![image](https://user-images.githubusercontent.com/55932083/232136365-1282faba-f6ac-460c-8471-268bafc3d6f0.png)<br>
![image](https://user-images.githubusercontent.com/55932083/232136447-4d90a0c6-4892-4d6e-b827-aa9ca02b8608.png)<br>
Añadiremos un evento que controlara la distancia a la que se activara el enemigo para comenzar a seguir al jugador.<br>
![image](https://user-images.githubusercontent.com/55932083/232136949-74591c70-da00-4c70-a51c-393ef970fc13.png)<br>
Crearemos un nuevo evento de tipo "System" que comparará la distancia entre los puntos XY del jugador y los puntos XY del enemigo para indicarle a este si debe moverse o no<br>
![image](https://user-images.githubusercontent.com/55932083/232137188-6c970e07-d71d-441b-ae4a-21acb9c4df2e.png)<br>
![image](https://user-images.githubusercontent.com/55932083/232137871-47fa1d75-e2f9-4209-9399-03cee6b374ab.png)<br>
Al evento que acabamos de crear le añadimos una acción, en este caso la acción sera que el evento perseguir (el que hace que el enemigo persiga al jugador), se pondrá a true, lo que hará que el enemigo comience a seguir al jugador.<br>
![image](https://user-images.githubusercontent.com/55932083/232139801-932c4af7-62da-4328-9197-dc3bbe3cdcdb.png)<br>
![image](https://user-images.githubusercontent.com/55932083/232139888-0f05724b-0641-48c9-81c0-d4f856c3fca6.png)<br>
Como así seria muy aburrido ya que el enemigo se quedaria parado cuando se encontrase un obstaculo, lo arreglaremos añadiendo un evento nuevo que haga una simulación de salto.<br>
![image](https://user-images.githubusercontent.com/55932083/232140359-24bd9145-9781-4414-8818-d28350ee1c7d.png)<br>
Simulamos el control de salto como una acción a realizar cuando el enemigo esta bloqueado por un obstaculo.<br>
![image](https://user-images.githubusercontent.com/55932083/232141187-2425d656-2b19-449d-abf8-0bf5387f94df.png)<br>
Convertimos el bloque del evento en un bloque OR. (para darle dos posibilidades de acción , una obstáculo a la izquierda y otro a la derecha)<br>
![image](https://user-images.githubusercontent.com/55932083/232140936-d86759e9-3453-4704-ae7a-0ca374612599.png)<br>
El bloque OR nos facilita el trabajo a la hora de que si hay algun problema, falla algo en la programación solo habría que corregirlo una vez y no varias, siendo mas eficiente.<br>
## 3.4 Añadir disparos
Sera la mecánica principal, primeros debemos pensar ¿Qué es una bala? un objeto que sale de nuestro personaje y avanza en linea recta.<br>
### 3.4.1 Creación de la bala.
Crear un objeto que sea una bala a partir de un sprite.<br>
![image](https://user-images.githubusercontent.com/55932083/232529962-83a8609e-5bf3-4e4f-852b-0cc0b96a94f5.png)<br>
Construct tiene un comportamiento predefinido para balas por lo cual sera mas sencillo programarlo, habrá que ir a "behaviors" y añadir un comportamiento de tipo "Bullet".<br>
![image](https://user-images.githubusercontent.com/55932083/232530770-8fc129b5-585d-430e-bdf1-48e31b3fd7cc.png)<br>
Añadimos una función para reiniciar el juego con un atajo de teclado para que sea mas fácil testear nuestro juego.<br>
![image](https://user-images.githubusercontent.com/55932083/232532003-2f2d8ac6-26cf-4d9a-87eb-d8ee9155ed37.png)<br>
Hacemos un grupo nuevo haciendo clic derecho en el event sheet  para añadir la codificacion de la bala<br>
![image](https://user-images.githubusercontent.com/55932083/232533107-44d3fd3e-d5fc-4e02-b345-17f0346c8534.png)<br>
Dentro del grupo comenzamos a hacer nuestro evento de disparar balas<br>
![image](https://user-images.githubusercontent.com/55932083/232537597-78d9a5c5-efb3-44b6-989f-a8851747706f.png)<br>
![image](https://user-images.githubusercontent.com/55932083/232537614-d4bfc959-d9cd-480e-8354-9d1c2a208f90.png)<br>
Añadimos una acción de sistema el cual será crear un objeto al pulsar el espacio<br>
![image](https://user-images.githubusercontent.com/55932083/232537835-69339482-be27-4b04-8a8b-288f16f07274.png)<br>
![image](https://user-images.githubusercontent.com/55932083/232560467-468b8cd9-d6f3-401c-84b6-a36bbc1741f7.png)<br>
Layer: sera la capa en la que esta<br>
X y Y: en este caso seran de donde sale la bala, es decir el jugador<br>
y haremos que la bala se destruya al salirse de la pantalla ya que si no consumirá muchos recursos porque se generarán balas infinitas y son objetos que se desplazan y consumen recurso<br>
![image](https://user-images.githubusercontent.com/55932083/232561914-d10fed43-a6cd-4c49-a597-e97e18d0e4b2.png)<br>
## 3.5 Añadir puntuación
### 3.5.1 Añadir colisión con el enemigo.
Primero empezaros por poder elegir la dirección en la que dispara el personaje.<br>
Para ello añadiremos una variable a nuestro objeto Player.<br>
![image](https://user-images.githubusercontent.com/55932083/232565635-1f0a4592-01b1-4147-848a-383e88ad78cb.png)<br>
Esta variable nos permitira controlar si una booleana se pone a true o se pone a False cuando pulsemos las teclas de movimiento.<br>
![image](https://user-images.githubusercontent.com/55932083/232565734-75ab5ebd-7bde-4236-9a36-3d93e9e13bf4.png)<br>
Dependiendo de lo que nos marque esta booleana haremos un sub evento en la funcion de disparar la cual indica la dirección de la bala, indicandole que si la booleana es falsa, la bala se disparara en la otra dirección<br>
![image](https://user-images.githubusercontent.com/55932083/232565896-48f2c435-8406-4c71-bf14-176281ddf3f1.png)<br>
Ahora haremos que el enemigo se destruya cuando una bala lo golpee, para ello crearemos un evento on collision.<br>
![image](https://user-images.githubusercontent.com/55932083/232566968-920806cf-317f-405b-a80b-0e1dac1ac399.png)<br>
![image](https://user-images.githubusercontent.com/55932083/232566988-5453bd3e-b040-435f-9b9d-2f707fad14e5.png)<br>
Haremos que su acción sea destruir al enemigo si lo golpea.<br>
![image](https://user-images.githubusercontent.com/55932083/232567085-4c64da18-4092-41ac-8668-ec82e36f9118.png)<br>
### 3.5.2 Añadir texto.
Añadiremos un objeto texto para saber la puntuación que tenemos(número de enemigos con los que hemos acabado)<br>
![image](https://user-images.githubusercontent.com/55932083/232567720-3391c25e-a09e-4812-925c-8cb42e763625.png)<br>
Creamos una variable de tipo puntuacion en el jugador.<br>
Mediante un evento en la bala hacemos que cada vez que golpee a un enemigo el contador aumente en 1 y asimismo vinculamos esta puntuacion con otro evento para que se modifique el texto de puntiación.<br>
![image](https://user-images.githubusercontent.com/55932083/232568705-bb114e43-43e6-4a21-abd2-55c149e9b228.png)<br>
## 3.6 Añadir puntuación
### 3.6.1 Añadir IA a todos los enemigos
Construct maneja las copias de los objetos como instancias y las maneja de maneras diferentes ya que por ejemplo en este caso si añadimos un enemigo uno el enemigo copia no se movería, solo lo haría el original y lo que queremos es que la comprobación de la distancia del enemigo con el jugador la haga cada una de las instancias, para ello utilizaros un foreach sobre la comprobación de la distancia<br>
![image](https://user-images.githubusercontent.com/55932083/232570640-3b0c8f53-0540-48e5-9b79-fc8901e7e2b1.png)<br>
Tendríamos que añadir el foreach también al controlador del desplazamiento ya que si no lso enemigos extra se quedarían "pillados" yendose en la dirección que predeterminaria el enemigo original.<br>
![image](https://user-images.githubusercontent.com/55932083/232570985-86a4fb7e-1017-4f2a-9fe2-af5fca3e3148.png)<br>
### 3.6.2 Hacer que el juego se "termine"
Para hacer que el juego se termine simplemente haremos en este caso que, cuando un enemigo choque con nosotros el jugador, simplemente el jugador desaparezca.<br>
![image](https://user-images.githubusercontent.com/55932083/232571586-b37818fe-e2d5-4a49-a1b3-e3ac07b2dbbb.png)<br>
Como queremos que al morir haya algun indicativo en pantalla de que hemos muerto haremos lo siguiente.<br>
En este caso como es un protipo crearemos un sprite y escribiremos por ejemplo "MAL" para que salte en mitad de la pantalla al morir.<br>
Una vez creado este sprite haremos que inicialmente no sea visible y que se muestre cuando un enemigo nos toca añadiendo la acción.<br>
![image](https://user-images.githubusercontent.com/55932083/232572395-17d65234-ddcd-4d6e-900c-0ee8cdf1274f.png)<br>
Añadiremos 2 eventos mas, uno para que espere 2 segundos y otro para que una vez pasen esos 2 segundos el juego se reinicie automáticamente <br>
![image](https://user-images.githubusercontent.com/55932083/232572718-f4d44072-0070-4b85-802f-e5c44074e4f3.png)<br>
### 3.6.3 Hacer que el juego se "gane"
Para ganar el juego tendremos que llegar a una bandera que hay al otro lado, una vez la tocamos los enemigos se destruiran si es que todavía queda alguno vivo y saltara un mensaje en pantalla de victoria, para ello tendremos que:<br>
-Crear un Sprite bandera dibujado para prototipo y programarlo.<br>
-Darle los eventos correspondientes para que al tocar la bandera el juego se termine y en este caso se reinicie el juego automáticamente.<br>
-Los enemigos se destruyan al tocar la bandera.<br>
![image](https://user-images.githubusercontent.com/55932083/232574107-40566fbe-dfcd-48da-8b68-b6f7167675f6.png)<br>
## 4 Puliendo el juego
### 4.1 El game feel
El game feel es básicamente que un juego sea bonito o divertido, que sea atractivo y den ganas de jugar.<br>
El púlido final del juego 2D, hacerlo bonito y atractivo al final es lo que mas tiempo lleva, incluso puede llegar a llevar mas tiempo que la programación del mismo.<br>
Para hacer un movimiento de camara en Construct primero tendremos que crear un sprite y usaremos la funcion Scroll to.<br>
![image](https://user-images.githubusercontent.com/55932083/232577779-88bcc17c-c1c2-4fa5-af43-14c75a9876f6.png)<br>
Esto hará que la cámara se vaya desplazando conforme a este nuevo sprite.<br>
Como queremos que la cámara se mueva con el jugador haremos que la cámara se ancle a una posición del jugador y que cuando este se mueva en una dirección o la otra la cámara se mueva acorde.<br>
![image](https://user-images.githubusercontent.com/55932083/232579927-db7acdb5-c57a-41a8-b2aa-432960d53bd1.png)<br>
Como tal cual esta la cámara se desplaza de forma instantánea y "afea" el feel del juego utilizamos uan funcion lerp para que la camara dé la sensación de desplazamiento.<br>
![image](https://user-images.githubusercontent.com/55932083/232581557-fba4c0d3-4e51-4670-8665-924eb9407ad8.png)<br>
En la funcion lerp se indican la posicion del objeto, la posición a la que se quiere mover y la velocidad a la que se va a hacer el desplazamiento.<br>
![image](https://user-images.githubusercontent.com/55932083/232581691-4fb28086-d000-496c-b2ac-614b8a206a75.png)<br>
Creamos y asignamos una variable global para no tener que cambiar uno a uno el valor de la distancia de la cámara<br>
![image](https://user-images.githubusercontent.com/55932083/232582162-6b169b12-2a96-4d3b-af78-0f5d4ef68f5e.png)<br>
Por último hacemos que la cámara sea invisible.<br>
Para ello iremos a properties y en initial visibility pondremos invisible<br>
![image](https://user-images.githubusercontent.com/55932083/232583136-387619d9-97f1-4c4a-bfff-f233bc8bcdf8.png)<br>
### 4.2 Aplicar efectos al juego
ANtes de nada haremos que al puntuación se mueva con el personaje y no se quede anclada, pàra ellos selecionaremos la capa interfaz y en el menú de la izquierda iremos a "Parallax" y lo pondremos a 0,0<br>
![image](https://user-images.githubusercontent.com/55932083/233856689-7f8e138c-cc92-414b-b2e1-791326035959.png)<br>
Ahora si añadiremos algun efecto al juego, en este caso añadiremos un screen shake al disparar.<br>
Para ello itemos al evento de disparar y añadiremos una acción al objeto cámara.<br>
![image](https://user-images.githubusercontent.com/55932083/233856812-bed763a6-3525-47fe-9f89-2aa141d1db8c.png)<br>
En el submenú scroll to escogeremos "Shake".<br>
![image](https://user-images.githubusercontent.com/55932083/233856842-b173ea5c-d17b-48fb-88da-706fdf9e85ce.png)<br>
![image](https://user-images.githubusercontent.com/55932083/233857067-4384f440-ed8d-444a-9351-764ece222dfc.png)<br>
Y ahora le daremos una pequeña aleatoriedad a la salida de las balas, para ello iremos al grupo de disparo y cambiaremos el ángulo de disparo por ejemplo por 170* y random(20).<br>
![image](https://user-images.githubusercontent.com/55932083/233857287-0530bf38-59cd-473e-a671-95d85a67b57a.png)<br>
### 4.3 Añadir assets de arte
Crearemos un nuevo objeto Sprite como siempre y despues de descargarnos un packj gratuito de assets haremos que ese sprite sea la imagen de fondo de nuestro juego.<br>
![image](https://user-images.githubusercontent.com/55932083/233857816-55df103e-2ab7-42ae-9950-1df4af236bd7.png)<br>
Para este caso, simplemente pondremos imagenes encima de las paredes y el suelo ya que son imágenes de tamaños dispares y lo haremos a base de crear sprites.<br>
![image](https://user-images.githubusercontent.com/55932083/233858157-e21a72b4-392f-4763-823e-86c1d1b66f26.png)<br>
Para el personaje y que tenga animaciónes haremos lo mismo, crearemos un sprite y se lo pegaremos encima y luego ocultaremos el cuadrado azul feo.<br>
Para hacer la animación con construct en el apartado de Animations crearemos varias imágenes dentro del propio sprite que iran ciclando automáticamente.<br>
![image](https://user-images.githubusercontent.com/55932083/233858359-acf4f5de-7ab7-4117-9bcc-cef20c3b0b2b.png)<br>
Para que la imágen y la animación se peguen al jugador añadiremos un behaviour Pin al sprite.<br>
![image](https://user-images.githubusercontent.com/55932083/233858668-22c72cde-2508-4a16-9e25-f1f24cb3df98.png)<br>
Y añadiremos en un on start layout que la imágen se pege al jugador.<br>
![image](https://user-images.githubusercontent.com/55932083/233858856-43ae4467-08ac-4e5e-a76f-ea15e5f12e25.png)<br>
Y añadiremos una serie de acciónes para que construct sepa cuando tiene que mover las imágenes con cada acción y nos faltaría hacer que se gire al ir hacia la izquierda.<br>
![image](https://user-images.githubusercontent.com/55932083/233859024-3e0a0c41-ab8f-40e9-9c83-449c662bac62.png)<br>
Para que la imágen se gire solo habría que ir al control de personaje y decirle que cuando se pulse la tecla , el sprite de movimiento se quede "mirrored" o "Not mirrored".<br>
![image](https://user-images.githubusercontent.com/55932083/233859090-30fec32a-2f5c-4d4e-b556-4cb012c506d8.png)<br>
Haremos que el cuadrado de la hitbox sea invisible y el sprite se destruya al morir, y ya estaría el jugador con un personaje.<br>
![image](https://user-images.githubusercontent.com/55932083/233860022-700efb28-359a-4409-b132-93bbf1da79c0.png)<br>
![image](https://user-images.githubusercontent.com/55932083/233860053-5949869b-63b7-4039-b2ad-f31d78f866dd.png)<br>
### 4.4 Añadir audio
Primero de todo para poder añadir Audio habria que añadir el Objeto audio en los object types apra que en el event sheet empiecen a aparecer eventos de audio.<br>
![image](https://user-images.githubusercontent.com/55932083/234056313-675683b9-98fe-4116-a8ff-7645ab71ece7.png)<br>
Y asi quedaria despues de "Programar la reproducción de la música".<br>
![image](https://user-images.githubusercontent.com/55932083/234058312-f3a6990d-bd9c-4d08-945b-ef3b1e7a67ef.png)<br>
Así lo que conseguiremos es que la música solo funcione si la música no esta sonando, ya que si no cada vez que se reiniciase el juego al música volveria a sonar haciendose un bucle de audio.<br>
![image](https://user-images.githubusercontent.com/55932083/234058917-a99ac59f-066c-4030-8a19-f4cd19833a56.png)<br>
Así conseguiremos que se reproduzca un efecto de sonido de muerte cuando nso impacte un enemigo.<br>
### 4.5 Crear niveles
para Crear un nivel simplemente hab´ra que crear un nuevo layout y en el hacer el diseño del mundo y poner los enemigos como nosotros los queramos (esto no se suele hacer a mano como en este caso)<br>
lo que si vamos a hacer es vincular el nivel 1 con el nivel 2, ya que construct no sabe que tiene que hacer al terminar el nivel 1 y lo que haría sería repetirlo en bucle, para ello haremos lo siguiente.<br>
Iremos a nuestro evento de colision con la bandera y en vez de decirle que reinicie le diremos que vaya al layout 2 <br>
![image](https://user-images.githubusercontent.com/55932083/234061542-80977145-c8ed-4cba-8e59-89967f4fb9ce.png)<br>
Nuevamente, esto nso causaría un problema, en caso de haber por ejemplo 3 niveles , al tocal a bandera solo llegaríamos al nivel dos, para arreglar esto debemos crear una variable global que se incremente cada vez que tocamos la bandera para ir avanzando por los distintos niveles<br>
![image](https://user-images.githubusercontent.com/55932083/234063226-f6d2783b-8991-40ed-ac1f-fab3094caeb2.png)<br>
### 4.6 Progresión entre niveles
Para que al terminar el juego nos salga una ventana de victorai por ejemplo, debemos crear un nuevo Event sheet  y un último layout en el que pondremos los mensajes de victoria y de como se reiniciará el juego, solo hay que crear un nuevo layout, un nuevo event sheet y en el propio event sheet decir con que boton queremos que se reinicie el juego haciendo que las variables globales se reinicien, ya que si no al reiniciar el juego y tocar una bandera Construct seguiría asociando mal y buscando un nivel que no existiria.<br>
![image](https://user-images.githubusercontent.com/55932083/234065664-cdce336d-4895-44fd-aeee-3f15da8a6382.png)<br>
en OpenWebinars explican como hacer un fade transición al final de cada nivel, pero no puedo hacerlo porque el construct gratuito esta limitado y no puedo crear mas capas asi que esta sacado directametne del video de como se haría.<br>
![image](https://user-images.githubusercontent.com/55932083/234066413-314135b9-f9c7-4568-b53e-32e31637563a.png)<br>
Así cada vez que se empezase un nivel se vería la pantalla en negro al iniciar un nivel.<br>
Para que tambien se hicese el fade al terminar un nivel, para que no quede tan brusco en el cambio de niveles habría que añadir una variable a por ejemplo la cámara y hacer el siguiente evento.<br>
![image](https://user-images.githubusercontent.com/55932083/234066792-e392720a-1955-4a7e-8796-c1dab4205228.png)<br>
![image](https://user-images.githubusercontent.com/55932083/234066986-8e8fdebc-83e0-48c1-a44c-89089099b936.png)<br>

## 5 Terminar y publicar
### 5.1 Crear un menú
Para crear el menú crearemos un layout nuevo y un event sheet asociado a el, en el que simplemente le pondremos 2 bloques de texto y un botón para  hacer la funccion de jugar.<br>
Para poder usar la funcionalidad del raton en Construct tendremos que añadir el objeto mouse a nuestro proyecto.<br>
![image](https://user-images.githubusercontent.com/55932083/234069042-529d998b-a148-438c-862f-4bbb272b4cc7.png)<br>
### 5.1 Compilar y publicar
Para ello tendremos que ir al menú de exportar.<br>
![image](https://user-images.githubusercontent.com/55932083/234075102-21e672ce-de4e-4a86-95d2-c6b2a1a22745.png)<br>
Seleccionaremos HTML5<br>
![image](https://user-images.githubusercontent.com/55932083/234075289-293da1ba-7f99-4c99-9516-b866eac82ef3.png)<br>
Nos creamos una cuenta en la página itc.io y en nuestro perfil pulsaremos sobre subir nuevo proyecto<br>
![image](https://user-images.githubusercontent.com/55932083/234075847-24cc0136-7d43-488d-8e9c-b681bc2d0029.png)<br>
# 3.Phaser
Phaser es un Framework de libre distribución y Open Source (se puede modificar a gusto) que trabaja sobre JavaScript Y TypeScript.<br>

Agrego archivo del progreso con phaser porque literalmente el curso de openwebinars básico es copiando y pegando códigos predefinidos de Phaser.<br>
El curso de Phaser personalmente no me ha gustado porque es poco teórico  por asi decirlo y se hace difícil hacer anotaciónes<br>
# 4.Unity
## 1.Introducción a unity
### 1.1 Qué es unity?

-Herramienta de creación de videojuegos.<br>
-Usado en multitud de proyectos.<br>
-Aporta motores 3D,2D renderizado y exportación a multitud de plataformas.<br>
-No es solo utilizado para creación de juegos si no también en edición de algunas películas animadas.<br>
-Manual de usuario y API en constante desarrollo.<br>
-Comunidad muy grande de usuarios y cantidad de información disponible.<br>
-Se programa en C#.<br>

### 1.2 Origen y evolución de Unity
Nació en 2004 como GooBall pero fracasó, pero como habían desarrollado buenas herramientas no quisieron dejarlo morir y se acabó convirtiendo en el motor por excelencia de la app store para crear videojuegos y se fue actualizando constantemente.<br>
Unity 2019 -> desarrollo increíble de todas las funcionalidades de Unity.<br>

### 1.3 Plataformas soportadas
Unity originalmente era solo para Mac OS pero acabó siendo ejecutable también en Windows y es experimental en Linux.<br>

Capaz de exportar juegos a más de 30 plataformas distintas entre ellas PC VR Consolas…<br>
### 1.4 Licencias y creación de cuenta

id.unity.com para crear la cuenta.<br>
La cuenta va vinculada a la asset store de Unity para garantizar que las compras en la asset store estén siempre disponibles para nosotros.<br>
Las licencias se compran como “asientos” lo que no permite usar una sola licencia y hace necesario tener varias por ejemplo en una empresa.<br>

## 2 Unity hub
### 2.1 Qué es Unity hub?

Unity hub es una aplicación para gestionar nuestra cuenta y licencias, nuestros proyectos y las instalaciones y actualizaciones del editor.<br>

### 2.2 Descarga,instalación y configuración
Se descarga desde la página de Unity directamente.<br>
En el menú de UnityHub  podremos loguearnos en nuestra cuenta.<br>
Configurar UnityHub (Cambiar los presets de instalación en caso de que se tenga disco duro pequeños).<br>
Almacén en la nube y en disco duro.<br>
Acceso a tutoriales propios de Unity, proyectos tutoriales links a documentación  y presets.<br>
Detector de instalaciones de Unity tanto oficiales como la actualmente instalado y acceso a betas.<br>
Permite añadir a posteriori componentes que no se instalaron en la instalación inicial<br>

### 2.3 Creación de proyectos

Solamente tendremos que pulsar el botón New.<br>
Poner el nombre del proyecto a crear y la localización en disco que se quiere usar, asi tambien como la versión de Unity.<br>
Se pueden elegir templates dependiendo de lo que vayamos a desarrollar.<br>

### 2.4 Apertura de proyectos

En el UnityHub se puede ver la versión y donde se localiza  nuestro proyecto.<br>
Podremos cambiar la version de Unity a utilizar, pero hay que tener cuidado y precaución ya que básicamente se podría romper todo ya que son bastante peligrosos, sobre todo al usar versiones anteriores.<br>

## 3 Interfaz de usuario de Unity
### 3.1 Introducción al a interfaz de usuario de Unity
Bastante intimidante a primera vista, está compuesto por paneles configurables.<br>
Conocer bien la interfaz para trabajar correctamente y de forma más cómoda.<br>

### 3.2 Hierarchy View
Contiene los objetos con los que se va a trabajar.<br>
Contiene las escenas.<br>
Se pueden crear objetos vacíos, objetos 3D,2D, luces, Interfaces de usuario etc.<br>
Se pueden Renombrar los objetos creados para saber lo que estamos haciendo y incluso hacer copiar y pegar.<br>
Estructura padre hijo.<br>
Todos los objetos son hijos de la escena y dentro de la escena se puede hacer que los objetos sean hijos de otros objetos simplemente arrastrando el objeto que se quiere que sea hijo sobre el que queremos que se quiera que sea padre.<br>
Se puede activar o desactivar la visibilidad de los objetos en escena (como en photoshop).<br>
### 3.3 Scene View: Navegación
Es el Panel central de Unity donde aparecen todos los objetos con los que se está trabajando (lo que vendría siendo la pantalla).<br>
Se puede hacer clic con el ratón y se activa el modo navegación como si fuese un juego en primera persona, para visualizar lo que estamos haciendo, reescalar objetos etc.<br>
Haciendo clic sobre un objeto de la jerarquía nos permitirá ir directamente a ese objeto ( en caso de alejarnos mucho y lo perdamos de vista por ejemplo).<br>
### 3.4 Scene View: Gizmo
Básicamente el Gizmo(una brújula) indica la referencia entre nuestra cámara y el punto sobre el que estamos rotando la vista, para que nos podamos orientar en el eje de coordenadas y en nuestro mundo(Distinto de los Gizmos de las opciones de vista).<br>
Son los ejes XYZ , haciendo clic sobre una de las perspectivas se alinea directamente con los ejes, como en autocad.<br>
### 3.5 Scene View: Draw Mode
Es a efectos prácticos el modo de visualización de los objetos en pantalla mientras trabajamos ( para visualizar aristas, lineas de trazado, contrastes de color).<br>
Se trabaja normalmente en modo wireframe (Visualizar el objeto tal cual se verá en el juego).<br>
### 3.6 Scene View: Opciones de vista (Parte I)
Se puede cambiar entre visualización 2D y 3D.<br>
Se puede encender y apagar la luz(crear iluminación para ver como quedaría, desde la cámara).<br>
Se puede activar y desactivar también el sonido.<br>
Activar y desactivar efectos como la Skybox.<br>
### 3.7 Scene View: Opciones de vista (Parte II)
-Herramientas personalizadas: Muestra las herramientas personalizadas.<br>
-Cámara: permite editar la velocidad de movimiento de la cámara, el campo de visión, el foco..), solo es la cámara que se usa para visualizar, no tiene nada que ver con la del juego, se puede decir a Unity distancias de renderizado.<br>
-Gizmos: Se puede editar  el tamaño relativo de los iconos que indican el campo de visión la luz, el objeto seleccionado…<br>
-Panel de búsqueda: Nos permite buscar objetos específicos, al escribir el nombre los objetos de la escena cuyo nombre coincida conservarán su color, el resto lo perderán.<br>
### 3.8 Herramientas: Transformaciones

-Herramienta de mano: Sirve para moverse.<br>
-Herramienta mover: Permite mover los objetos por la escena dependiendo del plano que nosotros seleccionemos.<br>
-Herramienta rotación: Permite rotar objetos en la escena, otra vez, dependiendo del plano que seleccionemos rotara de una manera o otra, o rotarlos de forma libre.<br>
-Herramienta escala: Permite escalar los objetos cambiandolos el tamaño, se pueden escalar también dependiendo del eje seleccionado(solo crecerá en una dirección) o se puede hacer crecer o  
 encoger a todo el objeto entero de forma proporcionada.<br>
-Herramienta Rect Tool: Esta pensada sobre todo para trabajar en 2D, permite rotar y cambiar el tamaño de los objetos , se puede usar en 3D, pero solo trabajara sobre un plano.<br>
-Herramienta Universal: Es una herramienta que combina todas las anteriores en una sola, muy útil cuando hay que hacer muchos ajustes de forma continuada.<br>
-Herramientas personalizadas: Muestra las herramientas personalizadas (programadas por ti mismo).<br>
Todas las herramientas tienen atajos de teclado.<br>

### 3.9 Herramientas: Pivot/Center,Local/Global

-Pivot: Permite utilizar el pivote de un objeto(punto 0,0) para desplazar uno o más objetos en una selección múltiple siempre se muestra el pivote del último objeto seleccionado.<br>

-Center: Es como Pivot, pero Center se posiciona sobre un punto intermedio entre los dos o más objetos seleccionados.<br>

Dependiendo de la herramienta seleccionada, cada objeto girará sobre su propio pivote, o  sobre el punto intermedio entre ellos.<br>

-Global: Es un sistema de coordenadas global para todos los objetos.<br>

-Local: Es el sistema de coordenadas del propio objeto.<br>

Por ejemplo en una habitación si te desplazas sobre le sistema global de la habitación tú te moverás hacia el norte por ejemplo, pero si te giras hacia el oeste, si te sigues desplazando sobre el sistema global, seguirías desplazandote hacia el norte, pero si utilizas el Local te desplazarías al Este.<br>

### 3.10 Herramientas: Play,Pause,Step

-Play: Ejecutar el juego de forma continua.<br>
-Pause: Pausar el juego.<br>
-Step: Ejecutar el juego paso a paso (como cuando estamos haciendo debug en Java o C#) se puede usar cuando el juego está pausado y avanza frame a frame.<br>

El juego se puede iniciar en modo pausa para poder ejecutar el paso a paso y ver mas fácil que es lo que está pasando.<br>

### 3.11 Herramientas: Collab,Cuenta,Layer y Layouts

-Collab: Es un sistema de control versiónes, permite trabajar en un proyecto con varias personas.<br>
-Cuenta/nube: Abrir las organizaciones que colaboran con Unity (abrir el juego en la nube, compras dentro del juego, anuncios).<br>
-Layers:Son las capas del juego, se puede ocultar o mostrar capas de objetos enteras, es como las capas de photoshop.<br>
-Layouts: Permite modificar la vista del programa de Unity a nuestro gusto.<br>

### 3.12 Game View: Display y Aspect Ratio

-Game View: Es lo que muestra la cámara, lo que ve el Jugador, se pueden usar varias pantallas, Unity soporta hasta 8 pantallas y cada una sería una cámara diferente, por ejemplo en un simulador de vuelo en una pantalla se vería el mundo y en otro las cartas de navegación comunicación con la torre… etc, solo para Windows, Linux y Mac.<br>

-Aspect Ratio: No es recomendable usar free aspect, es el tamaño de pantalla que se va a usar, con free aspect se puede dar el tamaño de pantalla que se quiera, pero nos arriesgamos a que algo quede fuera de la pantalla del juego.<br>
Se pueden crear aspect ratios personalizados que en este caso se utilizarían por ejemplo para juegos de móvil, VGA (estilo clásico).<br>

### 3.13 Game View: Panel derecho
Consta de varias opciones, entre ellas:<br>
-Maximize On Play: Redimensiona la pantalla de juego automáticamente al tamaño de nuestra pantalla al iniciarlo.<br>

-Mute Audio: Sirve para quitar el sonido, útil para cuando has iniciado el juego miles de veces y estás cansado de la música de inicio.<br>

-Vsync: Opción de la última versión de Unity, sirve para utilizar el Vsync en el propio menú de desarrollo, el Vsync lo que hace es hacer que no se mande la orden de actualización hasta que se ha terminado de renderizar todo, para  evitar el tearing.<br>

-Stats: Muestra la carga del procesador, los decibelios(ruido) del juego, lo que tarda la CPU en procesar, cantidad de vértices,triángulos..<br>

### 3.14 Project View

Contiene todos los assets que se podrían utilizar en el juego, modelos, audios,fondos…<br>

Para copiar un proyecto completo solamente es necesario copiar la carpeta Assets Packages y ProjectSettings.<br>

Cada archivo de assets contiene archivos meta que Unity utiliza para saber qué recursos están relacionados dentro del proyecto, peligroso borrar desde el buscador, hacerlo desde dentro de Unity ya que se podría perder el proyecto entero.<br>

Ser organizado con las carpetas es primordial para no perderse y que sea todo un lío.<br>

### 3.15 Inspector
Es una vista dinámica, básicamente el inspector nos da información de cada asset,sonido,prop,luz opciones de modelo, importación y renderizado.<br>

De los objetos que estan en nuestra escena podemos cambiar el color de los objetos, hacer que assets que no tienen visualización dentro del juego en la programación nos salga visualmente.<br>

Permite modificar la posición de los objetos y hacer que sean estáticos.<br>

Desde el Inspector se puede hacer depuración (Debug) individualmente cada objeto.<br>

### 3.16 Consola

Muestra los mensajes de registro de Unity cuando el programa está funcionando<br>

-Clear on Play: limpia la consola cada vez que se pulse el botón de jugar.<br>

-Error Pause: Pausa automáticamente si iba a ocurrir un error para poder localizarlo fácilmente.<br>

Se pueden hacer búsquedas concretas en la consola de Unity.<br>

### 3.17 Personalización del layout

Shift+Espacio sirve para maximizar la ventana de la que tenga el foco el ratón.<br>

Los paneles de Unity se pueden mover con total libertad simplemente arrastrandolos y se  pueden acoplar con otros paneles, lo que se suele hacer es coger el panel del juego dejarlo flotante y ponerlo en otro monitor por ejemplo y trabajar libremente.<br>

La configuración de layouts que tengamos se puede guardar y en caso de cargarnos los layouts de Unity y liarla mucho podemos volver a poner los layouts de base de Unity con solo pulsar un botón.<br>
### 3.18 Menús

La  mayoría de opciones del menú son duplicados de las opciones que están en los propios layouts y, en general las principales opciones son las de cualquier IDE como abrir guardar proyectos copiar, pegar  abrir y cerrar paneles que hayamos cerrado sin querer etc.<br>

### 3.19 Preferencias

Editar->Preferencias, son las preferencias básicas del editor, es decir opciones del programa.<br>

Por ejemplo podemos hacer que Unity Recompile después de parar el juego o que pare el juego directamente y lo recompile.<br>

Unity gratis NO TIENE TEMA OSCURO (terrorismo).<br>

### 3.20 Project Settings

La  mayor diferencia entre project setting y preferencias es que Project  Settings son configuraciones específicas del proyecto  de Unity que estamos llevando a cabo y no del programa(menú editar, Project Settings).<br>

### 3.21 Package Manager

Window->Package manager<br>

Nos permite añadir nuevos paquetes ( o quitar ) a Unity y  nos permite  actualizar los mismos directamente desde aquí.<br>

Es posible que los paquetes que instalemos tengan dependencias por otros paquetes, lo que quiere decir que tendremos que descargarnos todos los paquetes que sean necesarios.<br>

Built-in Packages: Son paquetes propios de Unity y nos permiten desactivar sistemas enteros, por ejemplo si se va a realizar un juego 2D se puede desactivar el 3D para aligerar el propio juego.<br>

### 3.22 Shortcuts

Nos permite editar los atajos de teclado para ponerlos a nuestro gusto como en cualquier ID, se pueden crear varios perfiles por si se trabaja con otras personas y cada uno tiene sus preferencias (Edit->Shortcuts).<br>

## 4  Conceptos esenciales
### 4.1 GameObjects
Todo objeto que tenemos en Unity y está en el clasificador de jerarquías, se podría decir que un GameObject es un contenedor de componentes.<br>


### 4.2  Componentes

Son piezas funcionales de código, que mediante el mismo indican cómo va a funcionar un determinado objeto<br>

Los componentes se pueden ver en el Inspector y cada componente guarda diversas variables.<br>

Todo gameobject tiene como minimo un componente:
-Transform ya que es necesario para posicionar un objeto en la escena.<br>

Los componentes pueden tener dependencias entre ellos, es decir un componente puede necesitar de otro para funcionar.<br>

Se le pueden quitar dependencias a un componente, cambiar su orden, pero NO se le puede quitar el Transform, para ello hay que eliminar el componente.<br>

### 4.3 Creación de componentes

Los componentes son lineas de código de C# que añaden funcionalidades a los GameObjects.<br>

### 4.4 Tags
Los tags sirven para marcar y/o clasificar objetos.<br>
-Se puede utilizar para diferenciar objetos por codigo.<br>
-Se crean desde Edit-> Project Settings->  Tags & Layers.<br>
-Cuando se crean duplicados, los duplicados no se llaman igual, ya que tienen  “un apellido”, entonces al intentar buscarlos no los encontramos, añadiendo tags esto se remedia ya que el tag 
  no cambia.<br>
-No se pueden renombrar, habría que borrar y crear de nuevo.<br>

### 4.5 Tags: Ejemplo de uso
Demostración de funcionalidad mediante el siguiente código:<br>

private void OnCollisionEnter(Collision other){ if(other.gameObject.CompareTag("Enemigo")){ Debug.Log("Destruyendo enemigo: " + other.gameObject.name); Destroy(other.gameObject); } else if(other.gameObject.CompareTag("Amigo")){ Debug.Log("Hola amigo!"); }

Hace que los objetos al caer y tocar un suelo al que se le ha añadido el componente a los marcados con el tag enemigo los destruye y a los marcados con el tag amigo los saluda.<br>

### 4.6 Layer:Creación, asignación y uso
Las capas nos permiten agrupar objetos por categorías lo que nos permite definir a que objetos afectan  algunos sistemas como las físicas, iluminaciones etc.<br>
Al contrario que a los tags a las capas si que se les puede cambiar  el nombre sin necesidad de borrarlos.<br>
Si se quiere borrar una capa simplemente con dejar el nombre vacío sirve para borrarla.<br>
Se puede desactivar la interacción entre capas, para por ejemplo que un objeto atraviese a otro.<br>

### 4.7 Escenas:Concepto y uso

Contienen el entorno y objetos del juego<br>

-Se podrían tener escenas por ejemplo para un menú, opciones del juego, una pantalla de carga etc.<br>
-Ctrl+S shortcut para guardar.<br>
-Al guardar la escena se guarda todo, incluyendo los settings.<br>
-Las escenas están en la categoría de Assets.<br>
-Las escenas se pueden cargar o haciendo clic en ellas (a mano en preview) o mediante código(cuando el juego está en funcionamiento).<br>

### 4.8 Escenas: Edición multi-escena

En muchas ocasiones es útil poder trabajar con varias escenas a la vez.<br>

La escena en la que se cargan los managers y separar el escenario en distintas escenas para facilitar la carga de la escena y el trabajo de varias personas a la  vez.<br>

Es muy fácil trabajar con escenas múltiples a la vez, deben estar en la misma jerarquía para poder cargarlas y descargarlas, esto significa que, al cargarlas los objetos que pertenezcan a otra escena se verán en la escena principal, evitando así una carga innecesaria o un cambio abrupto entre distintas “fases” del juego.<br>

## 5 Asset Store
Es la tienda de Assets de Unity:<br>
-Código.<br>
-Texturas.<br>
-Materiales.<br>
-Modelos.<br>
-Animaciones.<br>
-Utilidades.<br>
-De pago y gratuitos.<br>

Unity ofrece distintos packs de ejemplo como parte de sus tutoriales<br>
## 6 Prefabs
### 6.1 ¿Qué es un prefab?

Un prefab es un GameObject que nos permite almacenar componentes y reutilizarlo como un asset, sería algo similar a una plantilla de objetos, como por ejemplo entornos(el interior de una habitación si hay que hacer muchas casas por ejemplo).<br>

Los cambios realizados sobre el prefab se realizan automáticamente a todas sus instancias creadas.<br>
### 6.2 Creación de un prefab

Simplemente para crear un prefab hay que arrastrar el GameObject a la carpeta que elijamos y a esto  se le llamaría instanciar un prefab, se puede instanciar sobre el editor o sobre el código del juego.<br>
Para añadir un prefab a nuestro juego simplemente lo tendremos que arrastrar a la ventana.<br>

### 6.3 Prefab Mode

-Los prefabs se pueden modificar para que afecten a todas las instancias<br>
-Para entrar en el modo de edición con hacer doble click sobre el prefab ya se podría editar<br>
-Esto abre una escena nueva en la que estará nuestro prefab (plantilla) y todo lo que editemos en esta escena afectará al prefab.<br>

### 6.4 Instance Override

Permite hacer pequeños cambios en las instancias del prefab sin romper su vínculo con el prefab.
-Añadir componentes.<br>
-Cambiando valores de propiedades.<br>
-Eliminando componentes.<br>
-Añadiendo hijos.<br>
(Efectivamente el del curso dice que es programador y no artista vaya bicho mas feo)<br>

Tiene limitaciones:
-No se pueden eliminar GameObjects hijos del prefab.<br>
-No se pueden cambiar los padres de un prefab.<br>

### 6.5 Aplicar valores desde la instancia

Si seleccionamos el objeto que hemos editado podemos editar todos los Overrides que le hemos hecho en la opción de overrides, y aquí se puede editar los cambios y aplicarlo directamente al prefab, haciendo que todos los objetos cambien así mismo estos cambios también se pueden deshacer los cambios.<br>

### 6.6 Prefabs anidados

Como el propio nombre indica nos permite tener prefabs dentro de otros prefabs
-Anidar un prefab es como añadir cualquier objeto.<br>
-Cada prefab mantiene su independencia.<br>

### 6.7 Variantes

Son variaciones de otros prefabs,  son similares a los overrides de instancias pero usando prefabs<br>

Para crearlo solamente hay que hacer:<br>
-Click derecho sobre un prefab Create/Prefab Variant o arrastrar el prefab otra vez a la carpeta proyecto y Unity ya pregunta si se quiere crear un variant o un prefab nuevo.<br>

### 6.8 Desempaquetado de Prefabs

Es la operación inversa de un Prefab,  para ello solamente hay que hacer click derecho en el objeto y  unpack prefab y volvería a ser un GameObject normal.<br>

## 7  Cache Server

### 7.1 Qué es el Cache Server?

Es una herramienta que incluye Unity para ahorrar tiempo cuando se cambia entre distintas plataformas o cuando se quiere importar Assets que ya han sido usados por otra persona que trabaja en el mismo proyecto que nosotros.<br>
Unity no utiliza el formato original de los assets, los convierte a un formato para la plataforma sobre la que está trabajando.<br>
Básicamente guarda una copia de los recursos ya convertidos para que cuando sea necesario volver a usarlos no tengan que volver a codificarse por completo.<br>

### 7.2 Servidor Local vs Remoto
Se puede trabajar con él en modo Local, Remoto o simplemente desactivado<br>
-Deshabilitado: no es recomendable, los recursos tendrán que importarse cada vez que se cambie de plataforma.<br>
-Local: Si no es necesario compartir la caché porque solo trabajamos nosotros.<br>
-Remoto: En un servidor externo, para trabajar en un equipo.<br>
#5. Componentes y API de Unity

## 1.Introducción  a la programación de componentes

### 1.1 GameObject y componentes.

Recordatorio:<br>
-GameObject: Objeto elemental de Unity, Contenedor de componentes.<br>
-Componente:Código que realiza funciones muy concretas(sobre el GameObject).<br>

### 1.2 Creación de componentes.

En Unity los Componentes no son más que clases que heredan de otra clase llamada MonoBehaviour.<br>
Los componentes se crean en la ventana de proyecto simplemente haciendo clic derecho->Create->C# script<br>
Nuestro componente creado hereda de MonoBehaviour que a su vez hereda de Behaviour que hereda de Component y este hereda de Object.<br>
nuestroComponente->MonoBehaviour->Behaviour->Component->Object.<br>
(Son todo clases de Unity y Object es un objeto propio de UnityEngine).<br>
Es muy sencillo crear componentes, al pulsar crear componente se abre directamente el IDE que nosotros tengamos predefinido.<br>
### 1.3 Atributos públicos de un componente
Los atributos de un componente son los valores de los atributos del mismo.<br>
Al crear atributos públicos aparecen directamente en el propio componente para modificar sus valores.<br>
Los datos se muestran siempre y cuando se puedan serializar.<br>
Puede haber atributos que no interese que se vea en el propio inspector, para ocultarlo con poner antes del atributo[HideInInspector] lo ocultara en el inspector.<br>
Con un atributo privado se puede hacer lo mismo, solo que de por sí el inspector no lo muestra, pero poniendo antes del atributo [SerializeField] forzaríamos al inspector a que lo muestre.<br>
También se pueden crear estructuras(struct) que vendrían siendo objetos, que contienen valores, los cuales se pueden añadir también a los componentes pero de por sí no se pueden serializar, si se quiere que se serialice un struct habría que indicarselo a Unity con [System.Serializable].<br>
### 1.4 Componente Transform.
Transform guarda la información sobre la posición rotación y escala de un objeto, este componente no se puede eliminar y todos los GameObject tienen uno.<br>
Si esta contenido dentro de un padre, su información es siempre relativa al padre aunque en código se pueden cambiar sus valores sobre el plano global o sobre el plano local.<br>

### 1.5 Transform vs transform.
-Transform-> es una Clase.<br>
-transform-> es una instancia de la clase Transform.<br>
transform hace referencia al Transform del objeto que lo contiene.<br>
Siempre tiene una referencia, ya que Transform es el único componente que no se puede borrar<br>

### 1.6 Atributos principales de Transform (Parte I).
-Atributos Up,right y Forward: Son los vectores que apuntan en esas direcciónes en el  espacio global.<br>
-Position,Rotation,LossyScale; Indican la posición, rotación y escala en el plano global.<br>
-localPosition,localRotation,localScale:Indican la posición, rotación y escala en el plano local.<br>
-childCount:Número de hijos del objeto.<br>
Algunos de los métodos mas utilizados:<br>
-Translate:Mueve el objeto la distancia que se le indique.<br>
-Rotate: Rota el objeto.<br>
-GetChild():Devuelve una referencia al transform del hijo número que se le pase.<br>
-LookAt: Sirve para rotar un objeto y que este apunte a la posición indicada.<br>
-SetParent: Sirve para modificar lo padres de un objeto,con null se eliminan todos los padres.<br>
-[Inverse]Transform: Convierte los valores del transform local al global y viceversa.<br>
### 1.7 Atributos principales de Transform (Parte II).
-Vector3:
Estructura con 3 atributos principales: x,y,z<br>
Tiene Métodos propios de manipulación:<br>
Distance,Angle,Lerp…<br>
-Tiene campos estáticos auxiliares:<br>
Son por así decirlo como accesos directos a posiciones predefinidas.<br>
Unity utiliza cuaterniones para rotar objetos (Algo complicado de matemáticas, pero no hace falta saber cómo funcionan para saber utilizarlos)<br>
los cuaterniones son Compactos y rápidos de interpolación sencilla y no sufren Gimbal Lock<br>

## 2.El ciclo de vida de un componente
Son las fases de un componente desde que nace( se crea ) hasta que muere ( se destruye ).<br>
### 2.1 Awake.
Forma parte del bloque de inicialización de un componente.<br>
Se ejecuta siempre que se cree el objeto o el componente.<br>
### 2.2 OnEnable.
Se ejecuta siempre que se activa el objeto que lo contiene.<br>
Así como Awake solo se activa una vez ( al creador del objeto ) y OnEnable se puede activar varias veces.<br>
### 2.3 Start.
Solo se ejecutará en el primer frame en el que el frame está activo.<br>
Los Start no se ejecutan hasta que no se ejecuten todos los Awake y todos los OnEnable.<br>
Componente que crea el recurso debería hacerlo en Awaken o en OnEnable y el que lo consume en Start, para así asegurarse de que el componente que va a utilizar ya se ha creado.<br>
### 2.4 OnDisable.
Se ejecuta cuando se desactiva un componente o un objeto completo.<br>
Así mismo OnDestroy se utiliza para limpiar recursos y se activa al cerrar la escena o destruir un objeto.<br>
### 2.5 Update.
El método Update es uno de los pilares centrales de la lógica del juego, es el primero que se ejecuta y está ejecutándose constantemente cada frame, marca en gran medida los FPS del juego.<br>
Se actualiza mediante:
-Movimientos.<br>
-Animaciónes.<br>
-Posiciones..<br>

### 2.6 FixedUpdate.
Tiene una frecuencia fija y se puede modificar en preferencias.<br>
Se ejecuta antes de cálculos de física y si se aplican fuerzas se hace desde aquí.<br>


### 2.7 LateUpdate.
En unity no se puede saber el orden de ejecución de los scripts, puede incluso variar entre simulación y simulación.<br>
Se lleva a cabo cuando han terminado todos los updates de todos los objetos de la escena.<br>
Ideal para llevar acciones que requieren que todos los objetos se hayan actualizado.<br>
Por ejemplo: Una cámara que sigue a un objeto o a un jugador.<br>

### 2.8 OnGUI.
Se utilizaba para crear interfaces de usuario.<br>
Se puede usar para crear herramientas personalizadas.<br>
Usa GUI y GUILayout.<br>
-GUI: hay que añadir elementos a mano y posicionarlos y darles tamaño.<br>
-GUILayout: Permite hacer interfaces de usuario más rápido y de forma más sencilla.<br>
Se ejecuta después de los renderizados, por ello se pinta encima de todos los demas componentes del juego.<br>
Básicamente es crear una interfaz mediante código.<br>

### 2.9 OnDrawGizmos.
Permite dibujar gizmos en la ventana de escena de Unity.<br>
-Gizmo: Gráfico asociado al componente o objeto<br>
Visualiza información del objeto:
-Valores.<br>
-Rangos.<br>
-Distancias.<br>
Gizmos.color: Cambiar color.<br>
Gizmos.DrawLine: Dibuja una línea.<br>

### 2.10 Uso de OnDrawGizmos.
Visualizar el rango de percepción de un objeto o enemigo.<br>
Para hacer un círculo visualizable alrededor del enemigo para saber su campo de visión se utilizaría por ejemplo DrawWireSphere y se pintara una esfera alrededor del objeto.<br>
OnDrawGizmosSelected hace lo mismo que el OnDrawGizmos normal solo que en vez de estar siempre encendidas solamente se encenderán las esferas al seleccionarlas.<br>

### 2.11 Precauciones al ejecutar.
En los scripts en Unity no hay un orden de ejecución por defecto.<br>
Se puede forzar en las opciones la ejecución prioritaria de algún script (Project Setting/Script Execution Order), pero es mejor no hacerlo y que sea el último recurso.<br>
Conocer el ciclo de vida de los componentes para no tener que recurrir a forzar los scripts.<br>
## 3 Acceso a componentes
### 3.1 Acceso a componentes de otros objetos<br>
La forma más sencilla es usar propiedades públicas, se pueden asignar directamente las referencias adecuadas desde Unity, básicamente sería como usar los  valores de otros objetos en programación normal  para acceder a sus diversos valores y manipularlos como  componentes.<br>
Permite especificar sólo una referencia o un array de ellas.<br>
### 3.2FindObjectsOfType
Enemy anEnemy =(Enemy)FindObjectOfType(TypeOf(Enemy)).<br>
Básicamente sirve para buscar en la lista de objetos en la escena un objeto.<br> 
Enemy[] enemyList=FindObjectsOfType<Enemy>().<br>
Guarda todos los objetos enemy en una lista de objetos Enemy .<br>
El primer código devuelve un total de enemigos.<br>
El segundo código devuelve CADA UNO de  los enemigos.<br>
### 3.3 Acceso a componentes propios
Tener que acceder a componentes del propio GameObject suele ser bastante común y para ello se pueden usar atributos públicos.<br>

Acceder a los componentes es como acceder a los componentes en un programa normal del propio C#:<br>
enemy=GetComponent<Enemy>();<br>
-Se utiliza GetComponent(s): el cual nos devolvería todos los componentes del objeto que tengan el nombre especificado.<br>
Tambien se puede acceder a componentes que esten por debajo o por encima en la jerarquia:<br>
GetComponent(s)InChildren: Para coger los componentes buscados por debajo de la jerarquía(hijos).<br>
GetComponent(s)InParent: Para coger los componentes buscados por encima de la jerarquía(padres).<br>

### 3.4 Añadir componentes en tiempo de ejecución

Se utiliza por ejemplo para simular el agarrar un objeto, se crearía un componente.<br>
Component GameObject.AddComponent(System.type);<br>
T GameObject.AddComponent\<T>();<br>
RigidBody que se añadiría al objeto para poder simular el agarre, y a la hora de soltarlo simplemente se destruiría el componente y ya se soltaría.<br>
T es un objeto genérico.<br>

## 4 Introducción a la API de Unity
### 4.1  Clase Debug
Print es un envoltorio para Debug.Log<br>
Hay varios tipos de Debuglogs:<br>
-Debug.Log: Información.<br>
-Debug.LogWarning: Advertencia.<br>
-Debug.LogError: Errores.<br>
Es una clase útil para depuración y detectar errores.<br>
Cuando se necesita pausar la ejecución del juego se utiliza Debug.Break.<br>
Tambien se puede formatear el mensaje con:<br>
-Debug.LogFormat.<br>
-Debug.LogWaningFormat.<br>
-Debug.LogErrorFormat.<br>
### 4.2 Clases Input

Teclado:<br>

-Input.GetKey: estado de la tecla.<br>
-Input.GetKeyDown: tecla acaba de pulsarse.<br>
-Input.GetKeyUp: tecla acaba de soltarse.<br>
-Keycode-> Es un enumerado que contiene todos los valores de teclas de teclado.<br>
No tiene ningun metodo para saber que tecla esta pulsada en ese momento.<br>
Para ello habría que usar un foreach para recorrer el enumerado, como este:<br>

foreach (KeyCode k in typeof(KeyCode).GetEnumValues()){ Debug.Log("Se ha pulsado la tecla " + k); }<br>

-Ejes y botones virtuales:

Están definidos en ProjectSettings/Input.<br>
Funciona igual que Input.GetKey.<br>
Simula los ejes de un mando.<br>
-Input.GetButton: Estado de la tecla.<br>
-Input.GetButtonDown: Tecla acaba de pulsarse.<br>
-Input.GetButtonUp: Tecla acaba de soltarse.<br>
Los Buttons no están enumerados, habría que saber el nombre que tiene cada uno.
-Ratón: Obtiene la posición del ratón en píxeles.<br>
Se puede saber si se ha pulsado alguno de los botones del ratón con:<br>
-Input.GetMouseButtonDown.<br>
-Input.GetMouseButtonUp.<br>
OJO-> Botón 0 es el botón principal, no tiene porque ser el click izquierdo, piensa en los zurdos.<br>

Dispositivos móviles:<br>

-Para probar Unity Remote.
Es necesario tener el SDK de Android para poder usarlo y configurarlo en  ProjectSettings/Editor.<br>
Puede recoger datos de funciones del móvil como el GPS,acelerómetro…<br>

### 4.3 Clase Screen

Nos da información sobre la ventana/pantalla en la que se esté ejecutando el juego.<br>
Podremos conseguir:<br>
-Resolución actual.<br>
-Resoluciones soportadas(recorriendo un array).<br>
-Establecer modo pantalla completa(No se puede comprobar en Unity per se, hay que crear un ejecutable).<br>
-Rotar(para móviles).<br>
-Puntos por pulgada(PPP).<br>

### 4.4 Clase Camera

Sirve para acceder a las funcionalidades de la cámara (cámara principal del juego) Camera.main(etiqueta MainCamera).<br>

-World Space: Sistema de coordenadas donde están los objetos de nuestra escena.<br>
-Screen Space: sistema de coordenadas de la pantalla desde (0,0) hasta el ancho y alto de la pantalla.<br>
-Viewport: Sistema de coordenadas que va desde (0,0) hasta (1,1).<br>

Conversión de coordenadas<br>

-WorldTo[Screen, Viewport]Point: Convierte una posición del mundo en un punto en la pantalla o Viewport.<br>
-ScreenTo[World, Viewport]Point: Convierte un punto de la pantalla en una posición en el mundo o Viewport.<br>
-ViewportTo[World,Screen]Point: Convierte un punto del viewport a un punto del mundo la pantalla.<br>

### 4.5 Clase Time
La clase time nos permite conocer el tiempo  de nuestro juego:
-Tiempo  que lleva la escena en  funcionamiento.
-Tiempo que tardan en procesarse los frames.
-Intervalos de ejecución.
-Consultar y modificar escalas de tiempo.


Time.time: Tiempo en segundos desde el inicio del juego.
Time.unscaledTime: Tiempo en segundos desde el inicio del juego sin contar con  la escala de tiempo.
Time.realtimeSinceStartup: Tiempo transcurrido desde el inicio del juego
Time.timeSinceLevelLoad: Tiempo desde que se ha iniciado el nivel actual
Time.deltaTime: Tiempo que ha pasado desde el último frame..
Time.fixedDeltaTime: Tiempo que transcurre entre cada actualización del sistema de físicas. 
Time.timeScale: Escala del tiempo.
Usos:

Añadimos unos botones para cambiar  la escala de tiempo


Al cambiar las escalas de tiempo el tiempo avanzaría más rápido o más despacio, y si tuviésemos una escena  en movimiento ocurriría lo misma, el movimiento ocurriría mas lento o más rápido

### 4.6 Transforms
Gestiona posición rotación y escala:
Translate:
-Desplaza un objeto cierta cantidad.:
	-Vector3..
	-Desplazamiento por ejes individuales.
- Espacio Local.
-Espacio Mundo.


los valores de los x y y z están entre -1  y 1, dependiendo si se mueve para izquierda o derecha arriba o abajo, en este caso el movimiento “no sería válido”, porque? porque estaríamos realizando un desplazamiento por cada actualización de  los fps, que quiere decir esto?  que si nuestro juego va a 60 fps en 1 segundo estaríamos desplazándonos 60 veces.
Para que el juego tuviese un desplazamiento normal  habría que hacer lo siguiente:
Distancia=velocidad*tiempo.
Distancia=velocidad*Time.deltaTime.
Indicaremos que la  velocidad depende del tiempo que ha pasado desde la actualización del último frame.

-Rotate:
Permite rotar un objeto:
-Alrededor de un eje concreto.
	-Vector3.
	-Ángulos independientes.
	-Eje+ángulo
-Indicar los grados que se quiere rotar por cada eje.
En un incremento de la rotación se utiliza también deltaTime para controlar la rotación del objeto.

Aprovechando el código del translate, podemos hacer el rotate.
Cuál es el principal problema? en el caso del transform.Rotate .

Al indicarle el ángulo de rotación, si no especificamos en el translate que el espacio del translate es el mundo (World) al estar rotando cada  segundo que pasa, al intentar desplazar el personaje se desplazaría sobre su propio eje, es decir en vez de desplazarse de izquierda a derecha se desplazaría como en una especie de orbita haciendo un circulo, porque su rotación cambiaría el eje local de desplazamiento.
LookAt.
-Básicamente es hacer que el objeto mire a una dirección o objeto concreto
Se puede modificar mediante:
-Vector3.
-Transform.

Haríamos que el personaje este observando siempre al punto 0.

Haríamos que el personaje esté siempre observándonos a nosotros(cámara principal, bastante inquietante).


### 4.7 Activación y desactivación de objetos y componentes.

A  veces es necesario desactivar objetos y componentes para activarlos posteriormente o hacer que estén iniciados o desactivados.

Desactivar:
-Objetos completos: GameObject.SetActive(boolean).
-Componentes individuales: Cambiar la propiedad bool “enabled” a true o false.
Desactivar un objeto detiene la ejecución de los métodos Update y Start.

Al pulsar la tecla D se desactivará el GameObject y al pulsar la E no se vuelve a activar, porque se desactiva la ejecución de su Update.

Para que lo anterior no ocurra tendremos que usar otro objeto como controlador, para poder activar y desactivar el gameobject que usamos

### 4.8  Instanciación de objetos
Instanciar -> Crear un objeto:
-Prefabs.
-Objetos de la escena.
Los objetos se instancian mediante Instantiate/GameObject).
	-Instantiate(GameObject,Vector3,Quaternion), instanciarlo en una posición
Si se abusa mucho de él nuestro rendimiento del videojuego  puede desplomarse.


Cada vez que se pulsa la tecla 1, se crea un clon, el problema es que al volver a instanciarlo, cada copia crearía una copia, por eso hay una Sphere(Clone)(Clone).
Para evitar esto, crearemos un objeto instanciador y utilizaremos un prefab.

El Ejemplo 2 estaría instanciando siempre el objeto en la posición designada en la instantiationPosition, y el Quaternion.Identity hara que el objeto NO se rote.

Así nos estaríamos asegurando que al pulsar la tecla 1 para instanciar un nuevo objeto, solo se crearía uno cada vez.
### 4.9  Destruir objetos.
Se utiliza el Método Destroy(object).
	-Funciona con GameObjects.
	-Funciona con componentes de los GameObjects.
	-Se puede retrasar la destrucción de los objetos con Destroy(Object,float delay).


Al pulsar la tecla M llevaríamos a cabo un suicidio(Se destruiría el objeto propio)
Al pulsar la tecla D se destruiría el objeto que le estemos pasando por inspector.


En este caso concreto, Rigidbody es un componente( hace que el objeto  tenga físicas por ejemplo de gravedad).
Al pulsar la R se destruiría el componente Rigidbody del objeto  que se le pase por inspector al objeto Destructor.


Destrucción de un objeto cuando transcurren los 5 segundos.

### 4.10  Clase Random
Permite añadir aleatoriedad a nuestro juego.
-Números.
-Colores.
-Vectores.
-Valores.


En este caso práctico Unity estaría  cogiendo un punto aleatorio dentro de una esfera de radio 10(en este casi) y crearía un objeto en esa posición aleatoria.


## 5 Co-rutinas

### 5.1  Ejecución retrasada con Invoke
 Invoke permite retrasar  la ejecución de un método específico el tiempo indicado.

En este caso por ejemplo, se  llama a  Invoke, Invoke busca el método SayHi y lo invoca 3 segundos más tarde de su invocación.

InvokeRepeating:
En esencia hace lo mismo que el Invoke normal, solo que invokeRepeating permite hacer que el código se ejecute con un retraso y luego se ejecute cada x segundos.

Es propenso a fallos y no es muy flexible porque detecta el nombre del método y no permite pasar datos al mismo.

## 5.2 Qué son las co rutinas
Una co-rutina es un método que puede detener su ejecución, devolver el  control al programa y continuar su ejecución más adelante.

Código para repetir un bucle con  un contador sin una co-rutina deteniendo el counter.

Código para Iniciar la Co-rutina.
Cómo se puede apreciar el código de la co rutina es mas simple y compacto, en este caso lo que estaría haciendo la co rutina seria:
-Activar el while.
-El bucle suma 0,1 al contador.
-Imprime el valor en pantalla.
-El Yield hace que el bucle devuelva el control al programa principal y no se ejecute otra vez hasta que haya pasado 1 segundo.


### 5.3 Instrucción YIELD
Las co-rutinas son iteradores.
Se utiliza YIELD para devolver un valor
Se puede utilizar de dos formas:
-YIELD break.
-YIELD return y la expresión a devolver(como en el  ejemplo anterior  que le indicamos que esperase 1 segundo).
Expresiones que puede devolver YIELD:
-WaitForSeconds(float).
-WaitForSecondsRealtime(float)
-WaitForFixedUpdate()
-WaitUntil(predicado)
-WaitWhile(predicado)
-AsyncOperation(operaciones asíncronas como  cargas de escenas o cargas de assets).
### 5.4 Creación de co-rutinas
-Son métodos que devuelven un IEnumerator.
-Contienen una instrucción YIELD aunque no se use nunca.
-Algunos métodos de Unity se pueden utilizar como co-rutinas como por ejemplo Start.
-En vez de declarar start como Void habría  simplemente  que declararlo como IEnumerator
-A  las  co-rutinas si que se le pueden pasar números como parámetro.

IEnumerator SampleCoroutine(float p1) {
    Debug.Log("Starting coroutine");
    yield return new WaitForSeconds(p1)
    Debug.Log("Coroutine finished");
}

### 5.5 Ejemplos de uso
Ejemplo break:

El código después del break se puede apreciar que lo esta  marcando como inaccesible, ya que el break detendría la co-rutina y no legaría nunca a ejecutar ese código.
Ejemplo null:


Con el null se detendría durante un frame.
Ejemplo WaitForSeconds

La principal diferencia con WaitForSeconds y WaitForSecondsRealtime es que al WaitForSeconds normal le afectaría la modificación de la escala de tiempo principal (Time.timescale=0,2f) y al Realtime el cambio en la escala de tiempo no le afectaría.
WaitForSeconds:

WaitForSecondsRealtime:

Ejemplo  WaitForFixedUpdate


Con el FixedUpdate se mantiene  en el mismo frame por eso el frame actual no cambia.
Ejemplo WaitUntil:

Se  ejecuta  la primera  vez y luego no vuelve a ejecutarse hasta que el contador de frames llega  a 100, por lo que se imprime el 101.
Ejemplo WaitWhile

Es el mismo caso  que el WaitUntil solo que a la inversa, en este caso mientras el  frameCount es inferior a 100 no realiza la siguiente  acción.
### 5.6 Ejecución de co-rutinas
Las co-rutinas se ejecutan mediante el método StartCoroutine.
Los  parámetros son :
-La cadena con el nombre de  la co-rutina.
-Máximo un parámetro.
StartCoroutine(String,[param]).
O también pasandole un IEnumerator:
StartCoroutine(IEnumerator)..
Inicialización buscando el IEnumerator con un string:

Inicialización usando IEnumerator directamente:

En este caso se realiza una llamada directa al IEnumerator.
Usar la llamada  directa  al IEnumerator tiene varias ventajas :
-No  hay posibilidad de equivocarse al escribir el string del nombre ya que es una  invocación directa al método.
-Al ser una invocación al método acepta más de un parámetro,cosa que la invocación con el string no permite.

### 5.7 Detener co-rutinas
Hay varias maneras de detener una co-rutina:
-StopCoroutine(String).
-StopCoroutine(IEnumerator).
-StopCoroutine(Coroutine)
-StopAllCoroutines(detiene todas las co-rutinas que están siendo ejecutadas por un GameObject).




Ejemplo usando el string:

Ejemplo usando el IEnumerator:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/19ca73af-15bd-4e5f-9272-6410140a96ad)

En este caso habría que declarar el IEnumerator Cr, darle el valor de la co-rutina que se esta ejecutando y usarlo para detenerla.

Ejemplo usando Coroutine:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/f9917db7-f422-4be3-b060-4ea0dc3ba95e)

Es prácticamente igual a IEnumerator solo que en vez de declarar un IEnumerator cr se declara una Coroutine cr y se guarda directamente el valor de StartCoroutine.
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/4ff7df08-3b54-4bc2-8dc6-ab345d12968f)

Ejemplo StopAllCoroutines:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/258c7849-230b-4a36-9319-e15e407ea6de)

### 5.8 Encadenar co-rutinas
Las co-rutinas pueden esperar la finalización de otra co-rutina o pueden ejecutarse en paralelo tanto de forma  síncrona como de forma asíncrona.
Esperando la finalización de otra:
-yield return StartCoroutine(IEnumerator)
Al terminar la co-rutina llamara a la siguiente co-rutina a ejecutarse.
-Coroutine b=startCoroutine(IEnumerator);
Yield return b;

Inicio de una co-rutina mediante otra co-rutina:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/7fb93d7e-0aff-46aa-8fd4-fdbbbfd400f2)

Básicamente se lanza una co-rutina desde dentro de otra co-rutina, y la primera no termina hasta que termina la segunda.

Lanzamiento en paralelo:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/77ed6d61-3b84-4809-80f1-1dafe67a88f7)

Se guarda una referencia a la co-rutina que se lanza en paralelo para que la primera espere el tiempo de ejecución de la segunda.

Ejecutar co-rutinas en paralelo no es lo mismo que ejecutar varios hilos a la vez, se siguen lanzando unas después de otras pero lo hacen dentro del mismo frame.


### 5.9 Ejemplos de co-rutinas
Cambio de material:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/41983abd-c09d-4045-9a8c-95b5ff59ddd9)


Camera shake:
![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/97ae9fb4-3d63-4cc9-b3a7-2b7f393012eb)

![image](https://github.com/CostasDoMarcos/Marcos-FCT/assets/55932083/de4d364b-5b31-424e-a93d-e104450810b3)

Video de cameraShake y CambioColor añadidos en carpeta VideoUnity(abrir con volúmen bajo,hay un pitido que no fui capaz de eliminar)



































